<!DOCTYPE html> <!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]--> <!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8"><![endif]--> <!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9"><![endif]--> <!--[if gt IE 8]><!--> <html class="no-js"><!--<![endif]--> <head> <meta charset="UTF-8"> <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"> <meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"> <title>CPP Primer Reading Log: Class &#8211; Chaoyu Wang</title> <meta name="description" content="Moon is a minimal, one column jekyll theme for your blog."> <meta name="keywords" content="reading log, cpp"> <!-- Twitter Cards --> <meta name="twitter:card" content="summary"> <meta name="twitter:image" content="https://planck35.github.io/assets/img/planck.png"> <meta name="twitter:title" content="CPP Primer Reading Log: Class"> <meta name="twitter:description" content="Personal reading log."> <!-- Open Graph --> <meta property="og:locale" content="en_US"> <meta property="og:type" content="article"> <meta property="og:title" content="CPP Primer Reading Log: Class"> <meta property="og:description" content="Personal reading log."> <meta property="og:url" content="https://planck35.github.io/reading-log-class/"> <meta property="og:site_name" content="Chaoyu Wang"> <meta property="og:image" content="https://planck35.github.io/assets/img/planck.png"> <link rel="canonical" href="https://planck35.github.io/reading-log-class/"> <link href="https://planck35.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="Chaoyu Wang Feed"> <!-- Handheld --> <meta name="HandheldFriendly" content="True"> <meta name="MobileOptimized" content="320"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- CSS --> <link rel="stylesheet" href="https://planck35.github.io/assets/css/main.css"> <!-- JS --> <script src="https://planck35.github.io/assets/js/modernizr-3.3.1.custom.min.js"></script> <!-- Favicons --> <link rel="apple-touch-icon" href="https://planck35.github.io/assets/img/favicons/apple-icon-precomposed.png"> <link rel="apple-touch-icon" sizes="72x72" href="https://planck35.github.io/assets/img/favicons/apple-icon-72x72.png"> <link rel="apple-touch-icon" sizes="114x114" href="https://planck35.github.io/assets/img/favicons/apple-icon-114x114.png"> <link rel="apple-touch-icon" sizes="144x144" href="https://planck35.github.io/assets/img/favicons/apple-icon-144x144.png"> <link rel="shortcut icon" type="image/png" href="https://planck35.github.io/favicon.png" /> <link rel="shortcut icon" href="https://planck35.github.io/favicon.ico" /> <!-- Background Image --> <style type="text/css">body {background-image:url(https://planck35.github.io/assets/img/cmu-tartan-swatch.png); background-repeat: no-repeat; background-size: cover; }</style> <!-- Post Feature Image --> </head> <body> <nav id="dl-menu" class="dl-menuwrapper" role="navigation"> <button class="dl-trigger">Open Menu</button> <ul class="dl-menu"> <li><a href="https://planck35.github.io/">Home</a></li> <li> <a href="#">About</a> <ul class="dl-submenu"> <li> <img src="https://planck35.github.io/assets/img/planck.png" alt="Chaoyu Wang photo" class="author-photo"> <h4>Chaoyu Wang</h4> <p>Moon is a minimal, one column jekyll theme for your blog.</p> </li> <li><a href="https://planck35.github.io/about/"><span class="btn btn-inverse">Learn More</span></a></li> <li> <a href="http://linkedin.com/in/chaoyuw" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-linkedin-square"></i> LinkedIn</a> </li> <li> <a href="http://github.com/Planck35" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-github"></i> Github</a> </li> <li> <a href="http://stackoverflow.com/users/9555758/planck35 from a "http://stackoverflow.com/users/9555758/planck35" link" target="_blank" rel="noopener noreferrer"><i class="fa fa-fw fa-stack-overflow"></i> StackOverflow</a> </li> </ul><!-- /.dl-submenu --> </li> <li> <a href="#">Posts</a> <ul class="dl-submenu"> <li><a href="https://planck35.github.io/posts/">All Posts</a></li> <li><a href="https://planck35.github.io/tags/">All Tags</a></li> </ul> </li> <li><a href="https://planck35.github.io/projects/" >Projects</a></li> <li><a href="https://planck35.github.io/blog/" >Blog</a></li> </ul><!-- /.dl-menu --> </nav><!-- /.dl-menuwrapper --> <!-- Header --> <header class="header" role="banner"> <div class="wrapper animated fadeIn"> <div class="content"> <div class="post-title "> <h1>CPP Primer Reading Log: Class</h1> <h4>20 Dec 2019</h4> <p class="reading-time"> <i class="fa fa-clock-o"></i> Reading time ~6 minutes </p><!-- /.entry-reading-time --> <a class="btn zoombtn" href="https://planck35.github.io/posts/"> <i class="fa fa-chevron-left"></i> </a> </div> <blockquote> <p>2019/12/20 Class, cpp primer: 332 - 394</p> </blockquote> <p>The only difference between <code class="highlighter-rouge">struct</code> and <code class="highlighter-rouge">class</code> is the default access level. A class may define members before the first access specifier. Access to such members depends on how the class is defined. For <code class="highlighter-rouge">struct</code> keyword, the members are <code class="highlighter-rouge">public</code>; For <code class="highlighter-rouge">class</code>, the members are <code class="highlighter-rouge">private</code>.</p> <p>Following type alias is equivalent:</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="p">;</span>
<span class="k">using</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span><span class="p">;</span></code></pre></figure> <h2 id="returning-this-a-const-member-function">Returning *this a const member function</h2> <p>A <code class="highlighter-rouge">const</code> member function that returns <code class="highlighter-rouge">*this</code> as a reference should have a return type that is a reference to <code class="highlighter-rouge">const</code>.</p> <p>We can refer to a class type directly, by using the class name as a type name. Alternatively, we can use the class name following the keyword class or struct:</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Sales_data</span> <span class="n">item1</span><span class="p">;</span> <span class="c1">// default-initialized object of type Sales_data
</span><span class="k">class</span> <span class="nc">Sales_data</span> <span class="n">item1</span><span class="p">;</span> <span class="o">//</span> <span class="n">equivalent</span> <span class="n">declaration</span></code></pre></figure> <p>After a declaration and before a definition of a <code class="highlighter-rouge">class</code> is seen, this <code class="highlighter-rouge">class</code> is an <strong>incomplete type</strong>, A <code class="highlighter-rouge">class</code> must be defined-not just declared-before we can create objects of that type and a reference or pointer is used to access a member of the type.</p> <h2 id="friendship-between-classes">Friendship between Classes</h2> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Screen</span> <span class="p">{</span>
    <span class="c1">// Window_mgr members can access the private parts of class Screen
</span>    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Window_mgr</span><span class="p">;</span>
    <span class="c1">// ... rest of the Screen class
</span><span class="p">};</span></code></pre></figure> <p>The member functions of a friend class can access all the members, including the <code class="highlighter-rouge">nonpublic</code> members of the class granting friendship.</p> <p>It is important to understand that friendship is not transitive. That is, if class <code class="highlighter-rouge">Window_mgr</code> has its own friends, those friends have no special access to <code class="highlighter-rouge">Screen</code>.</p> <p class="notice">Each class controls which classes or functions are its friends.</p> <p>Rather than making the entire <code class="highlighter-rouge">Window_mgr</code> class a friend, <code class="highlighter-rouge">Screen</code> can instead specify that only the <code class="highlighter-rouge">clear</code> member is allowed access.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Screen</span> <span class="p">{</span>
    <span class="c1">// Window_mgr::clear must have been declared before class Screen
</span>    <span class="k">friend</span> <span class="kt">void</span> <span class="n">Window_mgr</span><span class="o">::</span><span class="n">clear</span><span class="p">(</span><span class="n">ScreenIndex</span><span class="p">);</span>
    <span class="c1">// ... rest of the Screen class
</span><span class="p">};</span></code></pre></figure> <p>Making a member function a friend requires careful structuring of the programs:</p> <ul> <li>First, define the <code class="highlighter-rouge">Window_mgr</code> class, which declares, but <strong>cannot define</strong> <code class="highlighter-rouge">clear()</code>.</li> <li>Define class <code class="highlighter-rouge">Screen</code>, including a friend declaration for <code class="highlighter-rouge">clear()</code>.</li> <li>Define <code class="highlighter-rouge">clear()</code>, which can now refer to the members in <code class="highlighter-rouge">Screen</code>.</li> </ul> <p class="notice">I think why not define <code class="highlighter-rouge">clear()</code> first, is that if so, the clear will not have any idea about the member of <code class="highlighter-rouge">Screen</code> class, because it is not a friend function yet.</p> <p>Although overloaded functions share a common name, they are still different functions. Therefore, a class must declare as a friend each function in a set of overloaded functions that it wishes to make a friend.</p> <h2 id="friend-declarations-and-scope">Friend Declarations and Scope</h2> <p>Classes and nonmember functions <strong>need not have been declared</strong> before they are used in a friend declaration. When a name first appears in a friend declaration, that name is implicitly assumed to be part of the surrounding scope. <strong>However, the friend itself is not actually declared in that scope</strong>.</p> <p><strong>Even if we define the function inside the class, we must still provide a declaration outside of the class itself to make that function visible.</strong> A declaration must exist even if we only call the friend from members of the friendship granting class.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* friend function can be defined in the class body */</span> <span class="p">}</span>
    <span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// error: no declaration for f
</span>    <span class="kt">void</span> <span class="n">g</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">h</span><span class="p">();</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">::</span><span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span> <span class="c1">// error: f hasn't been declared
</span><span class="kt">void</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// declares the function defined inside X
</span><span class="kt">void</span> <span class="n">X</span><span class="o">::</span><span class="n">h</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span> <span class="o">//</span> <span class="n">ok</span><span class="o">:</span> <span class="n">declaration</span> <span class="k">for</span> <span class="n">f</span> <span class="n">is</span> <span class="n">now</span> <span class="n">in</span> <span class="n">scope</span></code></pre></figure> <p>When a member function is defined outside the class body, any name used in the return type is outside the class scope. As a result, the return type must specify the class of which it is a member.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Window_mgr</span><span class="o">::</span><span class="n">ScreenIndex</span> <span class="n">Window_mgr</span><span class="o">::</span><span class="n">addScreen</span><span class="p">(</span><span class="k">const</span> <span class="n">Screen</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span></code></pre></figure> <p>The class member function bodies are not processed until the entire class is seen.</p> <p>Names used in member function declarations, including names used for the return type and types in the parameter list, must be seen before they are used.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="kt">double</span> <span class="n">Money</span><span class="p">;</span>
<span class="n">string</span> <span class="n">bal</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Account</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Money</span> <span class="n">balance</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">bal</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Money</span> <span class="n">bal</span><span class="p">;</span>
    <span class="c1">// ...
</span><span class="p">};</span></code></pre></figure> <p>When the compiler sees the declaration of the balance function, it will look for a declaration of Money in the Account class. On the other hand, the function body of balance is processed only after the entire class is seen. Thus, the return inside that function returns the member named bal, not the string from the outer scope.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">ConstRef</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ConstRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">ConstRef</span><span class="o">::</span><span class="n">ConstRef</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">)</span><span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span> <span class="n">ci</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span> <span class="n">ri</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span></code></pre></figure> <p>We must use the constructor initializer list to provide values for members that are <code class="highlighter-rouge">const</code>, reference, or of a class type that does not have a default constructor.</p> <h2 id="order-of-member-initialization">Order of Member Initialization</h2> <p>The order in constructor initializer list specifies only the values used to initialize the members, not the order in which those initializations are performed.</p> <p>Members are initialized in the order in which they appear in the class definition.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="c1">// undefined: i is initialized before j
</span>    <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span><span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span></code></pre></figure> <p class="notice">A constructor that supplies default arguments for all its parameters also defines the default constructor.</p> <h2 id="suppressing-implicit-conversions-defined-by-constructors">Suppressing Implicit Conversions Defined by Constructors</h2> <p>We can prevent the use of a constructor in a context that requires an implicit conversion by declaring the constructor as <code class="highlighter-rouge">explicit</code>:</p> <p>The explicit keyword is meaningful only on constructors that can be called with a single argument. Constructors that require more arguments are not used to perform an implicit conversion, so there is no need to designate such constructors as explicit.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Sales_data</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sales_data</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">p</span><span class="p">)</span><span class="o">:</span>
        <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">units_sold</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">revenue</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">explicit</span> <span class="n">Sales_data</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">bookNo</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">explicit</span> <span class="n">Sales_data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">istream</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">// remaining members as before
</span><span class="p">};</span></code></pre></figure> <p>Now, neither constructor can be used to implicitly create a Sales_data object.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">item</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">null_book</span><span class="p">);</span> <span class="c1">// error: string constructor is explicit
</span><span class="n">item</span><span class="p">.</span><span class="n">combine</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span> <span class="o">//</span> <span class="n">error</span><span class="o">:</span> <span class="n">istream</span> <span class="n">constructor</span> <span class="n">is</span> <span class="k">explicit</span></code></pre></figure> <p>One context in which implicit conversions happen is when we use the copy form of initialization (with an <code class="highlighter-rouge">=</code>). We cannot use an <code class="highlighter-rouge">explicit</code> constructor with this form of initialization; we must use direct initialization:</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="n">Sales_data</span> <span class="n">item1</span> <span class="p">(</span><span class="n">null_book</span><span class="p">);</span> <span class="c1">// ok: direct initialization
// error: cannot use the copy form of initialization with an explicit constructor
</span><span class="n">Sales_data</span> <span class="n">item2</span> <span class="o">=</span> <span class="n">null_book</span><span class="p">;</span></code></pre></figure> <p>When defining the <code class="highlighter-rouge">static</code> member functions, the <code class="highlighter-rouge">static</code> keyword is used only on the declaration inside the class body.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="c1">// define and initialize a static class member
</span><span class="kt">double</span> <span class="n">Account</span><span class="o">::</span><span class="n">interestRate</span> <span class="o">=</span> <span class="n">initRate</span><span class="p">();</span></code></pre></figure> <p>Note also that even though initRate is private, we can use this function to initialize interestRate. The definition of interestRate, like any other member definition, has access to the private members of the class.</p> <h2 id="static-member-special-use">Static member special use</h2> <p>A <code class="highlighter-rouge">static</code> data member can have incomplete type. In particular, a <code class="highlighter-rouge">static</code> data member can have the same type as the class type of which it is a member. Another difference between static and ordinary members is that we can use a static member as a default argument.</p> <figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Bar</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// ...
</span><span class="nl">private:</span>
    <span class="k">static</span> <span class="n">Bar</span> <span class="n">mem1</span><span class="p">;</span> <span class="c1">// ok: static member can have incomplete type
</span>    <span class="n">Bar</span> <span class="o">*</span><span class="n">mem2</span><span class="p">;</span> <span class="c1">// ok: pointer member can have incomplete type
</span>    <span class="n">Bar</span> <span class="n">mem3</span><span class="p">;</span> <span class="c1">// error: data members must have complete type
</span><span class="p">};</span></code></pre></figure> <div class="entry-meta"> <br> <hr> <span class="entry-tags"><a href="https://planck35.github.io/tags/#reading log" title="Pages tagged reading log" class="tag"><span class="term">reading log</span></a><a href="https://planck35.github.io/tags/#cpp" title="Pages tagged cpp" class="tag"><span class="term">cpp</span></a></span> <span class="social-share"> <a href="https://www.facebook.com/sharer/sharer.php?u=https://planck35.github.io/reading-log-class/" title="Share on Facebook" class="tag"> <span class="term"><i class="fa fa-facebook-square"></i> Share</span> </a> <a href="https://twitter.com/intent/tweet?text=https://planck35.github.io/reading-log-class/" title="Share on Twitter" class="tag"> <span class="term"><i class="fa fa-twitter-square"></i> Tweet</span> </a> <a href="https://plus.google.com/share?url=https://planck35.github.io/reading-log-class/" title="Share on Google+" class="tag"> <span class="term"><i class="fa fa-google-plus-square"></i> +1</span> </a> </span> <div style="clear:both"></div> </div> </div> </div> </header> <!-- JS --> <script src="https://planck35.github.io/assets/js/jquery-1.12.0.min.js"></script> <script src="https://planck35.github.io/assets/js/jquery.dlmenu.min.js"></script> <script src="https://planck35.github.io/assets/js/jquery.goup.min.js"></script> <script src="https://planck35.github.io/assets/js/jquery.magnific-popup.min.js"></script> <script src="https://planck35.github.io/assets/js/jquery.fitvid.min.js"></script> <script src="https://planck35.github.io/assets/js/scripts.js"></script> <script type="text/javascript"> var disqus_shortname = 'taylantatli'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); (function () { var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s); }()); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> <!-- MathJax --> <script async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> </body> </html>
